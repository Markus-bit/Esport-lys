import { model } from '@peter-murray/hue-bridge-model';
import * as api from './api';
declare const v3: {
    api: typeof api;
    discovery: {
        upnpSearch: (timeout: number) => Promise<import("./api/discovery/discoveryTypes").DiscoveryBridgeDescription[]>;
        nupnpSearch: () => Promise<import("./api/discovery/discoveryTypes").BridgeDiscoveryResponse[]>;
        description: (ipAddress: string) => Promise<import("./api/discovery/discoveryTypes").DiscoveryBridgeDescription | undefined>;
    };
    lightStates: {
        LightState: typeof model.LightState;
        GroupLightState: typeof model.GroupState;
        SceneLightState: typeof model.SceneLightState;
    };
    model: {
        lightStates: {
            LightState: typeof model.LightState;
            GroupLightState: typeof model.GroupState;
            SceneLightState: typeof model.SceneLightState;
        };
        timePatterns: {
            weekdays: typeof import("@peter-murray/hue-bridge-model/dist/esm/time").WEEKDAYS;
            isRecurring: typeof import("@peter-murray/hue-bridge-model/dist/esm/time").isRecurring;
            createAbsoluteTime: (value: string | Date | import("@peter-murray/hue-bridge-model/dist/esm/time").AbsoluteTime) => import("@peter-murray/hue-bridge-model/dist/esm/time").AbsoluteTime;
            createRandomizedTime: (value: string | Date | import("@peter-murray/hue-bridge-model/dist/esm/time").RandomizedTime) => import("@peter-murray/hue-bridge-model/dist/esm/time").RandomizedTime;
            createRecurringTime: (weekdays: number, value: string | Date | import("@peter-murray/hue-bridge-model/dist/esm/time").RecurringTime) => import("@peter-murray/hue-bridge-model/dist/esm/time").RecurringTime;
            createRecurringRandomizedTime: (value: string | Date | import("@peter-murray/hue-bridge-model/dist/esm/time").RecurringRandomizedTime) => import("@peter-murray/hue-bridge-model/dist/esm/time").RecurringRandomizedTime;
            createTimeInterval: (value: string | import("@peter-murray/hue-bridge-model/dist/esm/time").TimeInterval) => import("@peter-murray/hue-bridge-model/dist/esm/time").TimeInterval;
            createTimer: (value: string | import("@peter-murray/hue-bridge-model/dist/esm/time").Timer) => import("@peter-murray/hue-bridge-model/dist/esm/time").Timer;
            createRecurringTimer: (value: string | Date | import("@peter-murray/hue-bridge-model/dist/esm/time").RecurringTimer) => import("@peter-murray/hue-bridge-model/dist/esm/time").RecurringTimer;
            createRandomizedTimer: (value: string | import("@peter-murray/hue-bridge-model/dist/esm/time").RandomizedTimer) => import("@peter-murray/hue-bridge-model/dist/esm/time").RandomizedTimer;
            createRecurringRandomizedTimer: (value: string | import("@peter-murray/hue-bridge-model/dist/esm/time").RecurringRandomizedTimer) => import("@peter-murray/hue-bridge-model/dist/esm/time").RecurringRandomizedTimer;
            createFromString: typeof import("@peter-murray/hue-bridge-model/dist/esm/time").createFromString;
            isTimePattern: (str: string) => boolean;
        };
        createEntertainment: () => model.Entertainment;
        createLightGroup: () => model.LightGroup;
        createRoom: () => model.Room;
        createZone: () => model.Zone;
        createCLIPGenericFlagSensor: () => model.CLIPGenericFlag;
        createCLIPGenericStatusSensor: () => model.CLIPGenericStatus;
        createCLIPHumiditySensor: () => model.CLIPHumidity;
        createCLIPLightlevelSensor: () => model.CLIPLightlevel;
        createCLIPOpenCloseSensor: () => model.CLIPOpenClose;
        createCLIPPresenceSensor: () => model.CLIPPresence;
        createCLIPTemperatureSensor: () => model.CLIPTemperature;
        createCLIPSwitchSensor: () => model.CLIPSwitch;
        createLightScene: () => model.LightScene;
        createGroupScene: () => model.GroupScene;
        createSchedule: () => model.Schedule;
        actions: {
            light: (light: string | number | model.Light) => model.LightStateAction;
            group: (group: string | number | model.Group) => model.GroupStateAction;
            sensor: (sensor: string | number | model.Sensor) => model.SensorStateAction;
            scene: (scene: string | model.Scene) => model.SceneAction;
        };
        createRule: () => model.Rule;
        ruleConditions: {
            sensor: (sensor: model.Sensor) => model.SensorCondition;
            group: (id: string | number | model.Group) => model.GroupCondition;
        };
        createResourceLink: () => model.ResourceLink;
    };
};
export { v3 };
