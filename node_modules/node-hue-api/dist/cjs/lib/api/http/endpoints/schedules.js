"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schedulesApi = void 0;
const hue_bridge_model_1 = require("@peter-murray/hue-bridge-model");
const util_1 = require("../../../util");
const ApiEndpoint_1 = require("./ApiEndpoint");
const ScheduleIdPlaceholder_1 = require("../../placeholders/ScheduleIdPlaceholder");
const ApiError_1 = require("../../../ApiError");
const SCHEDULE_ID_PLACEHOLDER = new ScheduleIdPlaceholder_1.ScheduleIdPlaceholder();
const instanceChecks = hue_bridge_model_1.model.instanceChecks;
const schedulesApi = {
    getAll: new ApiEndpoint_1.ApiEndpoint()
        .get()
        .acceptJson()
        .uri('/<username>/schedules')
        .pureJson()
        .postProcess(buildSchedulesResult),
    createSchedule: new ApiEndpoint_1.ApiEndpoint()
        .post()
        .acceptJson()
        .uri('/<username>/schedules')
        .pureJson()
        .payload(buildSchedulePayload)
        .postProcess(buildCreateScheduleResult),
    getScheduleAttributes: new ApiEndpoint_1.ApiEndpoint()
        .get()
        .uri('/<username>/schedules/<id>')
        .placeholder(SCHEDULE_ID_PLACEHOLDER)
        .acceptJson()
        .pureJson()
        .postProcess(buildSchedule),
    setScheduleAttributes: new ApiEndpoint_1.ApiEndpoint()
        .put()
        .uri('/<username>/schedules/<id>')
        .placeholder(SCHEDULE_ID_PLACEHOLDER)
        .acceptJson()
        .payload(buildUpdateSchedulePayload)
        .pureJson()
        .postProcess(util_1.extractUpdatedAttributes),
    deleteSchedule: new ApiEndpoint_1.ApiEndpoint()
        .delete()
        .acceptJson()
        .uri('/<username>/schedules/<id>')
        .placeholder(SCHEDULE_ID_PLACEHOLDER)
        .pureJson()
        .postProcess(util_1.wasSuccessful),
};
exports.schedulesApi = schedulesApi;
function buildSchedulesResult(result) {
    let schedules = [];
    Object.keys(result).forEach(function (id) {
        schedules.push(hue_bridge_model_1.model.createFromBridge('schedule', id, result[id]));
    });
    return schedules;
}
function buildSchedule(data, requestParameters) {
    const id = SCHEDULE_ID_PLACEHOLDER.getValue(requestParameters);
    return hue_bridge_model_1.model.createFromBridge('schedule', id, data);
}
function buildSchedulePayload(parameters) {
    const schedule = parameters.schedule;
    if (!schedule) {
        throw new ApiError_1.ApiError('Schedule to create must be provided');
    }
    else if (!instanceChecks.isScheduleInstance(schedule)) {
        throw new ApiError_1.ApiError('You must provide a valid instance of a Schedule to be created');
    }
    const payload = getSchedulePayload(parameters.username, schedule);
    return {
        type: 'application/json',
        body: payload
    };
}
function buildUpdateSchedulePayload(parameters) {
    const schedule = parameters.schedule;
    if (!schedule) {
        throw new ApiError_1.ApiError('Schedule to update must be provided');
    }
    else if (!instanceChecks.isScheduleInstance(schedule)) {
        throw new ApiError_1.ApiError('You must provide a valid instance of a Schedule when updating');
    }
    const payload = getSchedulePayload(parameters.username, schedule);
    // Extract only the values we can update on a schedule
    const body = {};
    ['name', 'description', 'command', 'localtime', 'status', 'autodelete'].forEach(key => {
        if (payload[key] !== null) {
            body[key] = payload[key];
        }
    });
    return {
        type: 'application/json',
        body: body
    };
}
function buildCreateScheduleResult(result) {
    const hueErrors = util_1.parseErrors(result); //TODO not sure if this still gets called as the request handles some of this
    if (hueErrors) {
        throw new ApiError_1.ApiError(`Error creating group: ${hueErrors[0].description}`, hueErrors[0]);
    }
    const id = result[0].success.id;
    return {
        id: SCHEDULE_ID_PLACEHOLDER.getValue({ id: id })
    };
}
function getSchedulePayload(username, schedule) {
    const payload = schedule.getHuePayload();
    if (hue_bridge_model_1.timePatterns.isRecurring(payload.localtime)) {
        // autodelete does not apply to recurring schedules (as specified in the localtime)
        delete payload.autodelete;
    }
    // Fix the address from the action to start with "/api/{username}"
    const address = payload.command.address;
    if (!/^\/api\//.test(address)) {
        payload.command.address = `/api/${username}${address}`;
    }
    return payload;
}
