"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scenesApi = void 0;
const hue_bridge_model_1 = require("@peter-murray/hue-bridge-model");
const util_1 = require("../../../util");
const SceneIdPlaceholder_1 = require("../../placeholders/SceneIdPlaceholder");
const LightIdPlaceholder_1 = require("../../placeholders/LightIdPlaceholder");
const ApiEndpoint_1 = require("./ApiEndpoint");
const ApiError_1 = require("../../../ApiError");
const SCENE_ID_PLACEHOLDER = new SceneIdPlaceholder_1.SceneIdPlaceholder();
const instanceChecks = hue_bridge_model_1.model.instanceChecks;
const SceneLightState = hue_bridge_model_1.model.SceneLightState;
const scenesApi = {
    getAll: new ApiEndpoint_1.ApiEndpoint()
        .get()
        .acceptJson()
        .uri('/<username>/scenes')
        .pureJson()
        .postProcess(buildScenesResult),
    createScene: new ApiEndpoint_1.ApiEndpoint()
        .post()
        .acceptJson()
        .uri('/<username>/scenes')
        .pureJson()
        .payload(getCreateScenePayload)
        .postProcess(buildCreateSceneResult),
    updateScene: new ApiEndpoint_1.ApiEndpoint()
        .put()
        .acceptJson()
        .uri('/<username>/scenes/<id>')
        .placeholder(new SceneIdPlaceholder_1.SceneIdPlaceholder())
        .pureJson()
        .payload(buildBasicSceneUpdatePayload)
        .postProcess(util_1.extractUpdatedAttributes),
    updateSceneLightState: new ApiEndpoint_1.ApiEndpoint()
        .put()
        .acceptJson()
        .uri('/<username>/scenes/<id>/lightstates/<lightStateId>')
        .placeholder(SCENE_ID_PLACEHOLDER)
        .placeholder(new LightIdPlaceholder_1.LightIdPlaceholder('lightStateId'))
        .pureJson()
        .payload(buildUpdateSceneLightStatePayload)
        .postProcess(util_1.extractUpdatedAttributes),
    getScene: new ApiEndpoint_1.ApiEndpoint()
        .get()
        .acceptJson()
        .uri('/<username>/scenes/<id>')
        .placeholder(SCENE_ID_PLACEHOLDER)
        .pureJson()
        .postProcess(buildSceneResult),
    deleteScene: new ApiEndpoint_1.ApiEndpoint()
        .delete()
        .acceptJson()
        .uri('/<username>/scenes/<id>')
        .placeholder(SCENE_ID_PLACEHOLDER)
        .pureJson()
        .postProcess(validateSceneDeletion),
};
exports.scenesApi = scenesApi;
function buildScenesResult(result) {
    let scenes = [];
    Object.keys(result).forEach(function (id) {
        const data = result[id], type = data.type.toLowerCase();
        const scene = hue_bridge_model_1.model.createFromBridge(type, id, data);
        scenes.push(scene);
    });
    return scenes;
}
function buildSceneResult(data, requestParameters) {
    const type = data.type.toLowerCase(), id = SCENE_ID_PLACEHOLDER.getValue(requestParameters);
    return hue_bridge_model_1.model.createFromBridge(type, id, data);
}
function validateSceneDeletion(result) {
    if (!util_1.wasSuccessful(result)) {
        const parsed = util_1.parseErrors(result);
        throw new ApiError_1.ApiError(parsed ? parsed.join(', ') : `Unexpected result: ${JSON.stringify(result)}`);
    }
    return true;
}
function getCreateScenePayload(parameters) {
    const scene = parameters.scene;
    if (!scene) {
        throw new ApiError_1.ApiError('No scene provided');
    }
    else if (!instanceChecks.isSceneInstance(scene)) {
        throw new ApiError_1.ApiError('Must provide a valid Scene object');
    }
    const body = scene.getHuePayload();
    // Remove properties that are not used is creation
    delete body.id;
    delete body.locked;
    delete body.owner;
    delete body.lastupdated;
    delete body.version;
    return {
        type: 'application/json',
        body: body
    };
}
//TODO
function buildUpdateSceneLightStatePayload(parameters) {
    const lightState = parameters.lightState;
    if (!lightState) {
        throw new ApiError_1.ApiError('No SceneLightState provided');
    }
    else if (!(lightState instanceof SceneLightState)) {
        throw new ApiError_1.ApiError('Must provide a valid SceneLightState object');
    }
    //TODO need to validate this object to protect ourselves here
    const body = lightState.getPayload();
    return {
        type: 'application/json',
        body: body
    };
}
function buildBasicSceneUpdatePayload(parameters) {
    const scene = parameters.scene;
    if (!scene) {
        throw new ApiError_1.ApiError('No scene provided');
    }
    else if (!instanceChecks.isSceneInstance(scene)) {
        throw new ApiError_1.ApiError('Must provide a valid Scene object');
    }
    const scenePayload = scene.getHuePayload(), body = {};
    // Extract the properties that we are allowed to update as per the API docs
    ['name', 'lights', 'lightstates', 'storelightstate'].forEach(key => {
        const value = scenePayload[key];
        if (value !== null) {
            body[key] = value;
        }
    });
    return {
        type: 'application/json',
        body: body
    };
}
function buildCreateSceneResult(result) {
    const hueErrors = util_1.parseErrors(result); //TODO not sure if this still gets called as the request handles some of this
    if (hueErrors) {
        throw new ApiError_1.ApiError(`Error creating scene: ${hueErrors[0].description}`, hueErrors[0]);
    }
    return { id: result[0].success.id };
}
