"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sensorsApi = void 0;
const hue_bridge_model_1 = require("@peter-murray/hue-bridge-model");
const SensorIdPlaceholder_1 = require("../../placeholders/SensorIdPlaceholder");
const ApiEndpoint_1 = require("./ApiEndpoint");
const ApiError_1 = require("../../../ApiError");
const util_1 = require("../../../util");
const SENSOR_ID_PLACEHOLDER = new SensorIdPlaceholder_1.SensorIdPlaceholder();
const instanceChecks = hue_bridge_model_1.model.instanceChecks;
const sensorsApi = {
    getAllSensors: new ApiEndpoint_1.ApiEndpoint()
        .get()
        .uri('/<username>/sensors')
        .acceptJson()
        .pureJson()
        .postProcess(buildAllSensorsResult),
    createSensor: new ApiEndpoint_1.ApiEndpoint()
        .post()
        .uri('/<username>/sensors')
        .payload(buildSensorPayload)
        .acceptJson()
        .pureJson()
        .postProcess(buildCreateSensorResult),
    findNewSensors: new ApiEndpoint_1.ApiEndpoint()
        .post()
        .uri('/<username>/sensors')
        .acceptJson()
        .pureJson()
        .postProcess(util_1.wasSuccessful),
    getNewSensors: new ApiEndpoint_1.ApiEndpoint()
        .get()
        .uri('/<username>/sensors/new')
        .acceptJson()
        .pureJson()
        .postProcess(createNewSensorResponse),
    getSensor: new ApiEndpoint_1.ApiEndpoint()
        .get()
        .uri('/<username>/sensors/<id>')
        .placeholder(SENSOR_ID_PLACEHOLDER)
        .acceptJson()
        .pureJson()
        .postProcess(createSensorResponse),
    updateSensor: new ApiEndpoint_1.ApiEndpoint()
        .put()
        .uri('/<username>/sensors/<id>')
        .placeholder(SENSOR_ID_PLACEHOLDER)
        .payload(createUpdateSensorPayload)
        .acceptJson()
        .pureJson()
        .postProcess(util_1.wasSuccessful),
    deleteSensor: new ApiEndpoint_1.ApiEndpoint()
        .delete()
        .uri('/<username>/sensors/<id>')
        .placeholder(SENSOR_ID_PLACEHOLDER)
        .acceptJson()
        .pureJson()
        .postProcess(util_1.wasSuccessful),
    changeSensorConfig: new ApiEndpoint_1.ApiEndpoint()
        .put()
        .uri('/<username>/sensors/<id>/config')
        .placeholder(SENSOR_ID_PLACEHOLDER)
        .payload(buildSensorConfigPayload)
        .acceptJson()
        .pureJson()
        .postProcess(util_1.wasSuccessful),
    changeSensorState: new ApiEndpoint_1.ApiEndpoint()
        .put()
        .uri('/<username>/sensors/<id>/state')
        .placeholder(SENSOR_ID_PLACEHOLDER)
        .payload(buildSensorStatePayload)
        .acceptJson()
        .pureJson()
        .postProcess(util_1.extractUpdatedAttributes),
};
exports.sensorsApi = sensorsApi;
function buildSensorPayload(parameters) {
    let sensor = parameters.sensor;
    if (!sensor) {
        throw new ApiError_1.ApiError('Sensor to create must be provided');
    }
    else if (!instanceChecks.isSensorInstance(sensor)) {
        throw new ApiError_1.ApiError('You must provide a valid instance of a Sensor to be created');
    }
    const payload = sensor.getHuePayload();
    delete payload.id;
    return {
        type: 'application/json',
        body: payload
    };
}
function buildAllSensorsResult(data) {
    const result = [];
    if (data) {
        Object.keys(data).forEach(id => {
            const sensorData = data[id], type = sensorData.type.toLowerCase();
            try {
                const sensor = hue_bridge_model_1.model.createFromBridge(type, id, sensorData);
                result.push(sensor);
            }
            catch (err) {
                //TODO need better handling error reporting for this, but this stops us breaking when Hue invents new
                // undocumented sensors.
                console.error(`Failed to create sensor from bridge model: ${err}; payload: ${JSON.stringify(sensorData)}`);
            }
        });
    }
    return result;
}
function createSensorResponse(data, requestParameters) {
    const id = SENSOR_ID_PLACEHOLDER.getValue(requestParameters), type = data.type.toLowerCase();
    return hue_bridge_model_1.model.createFromBridge(type, id, data);
}
function createNewSensorResponse(data) {
    const result = {
        lastscan: '',
        sensors: []
    };
    if (data) {
        Object.keys(data).forEach(key => {
            if (key === 'lastscan') {
                result.lastscan = data.lastscan;
            }
            else {
                const type = data.type.toLowerCase(), sensor = hue_bridge_model_1.model.createFromBridge(type, key, data[key]);
                result.sensors.push(sensor);
            }
        });
    }
    return result;
}
function createUpdateSensorPayload(data) {
    if (!data || !data.name) {
        throw new ApiError_1.ApiError('A name must be provided');
    }
    return {
        type: 'application/json',
        body: {
            name: data.name
        }
    };
}
function buildCreateSensorResult(result) {
    const hueErrors = util_1.parseErrors(result); //TODO not sure if this still gets called as the request handles some of this
    if (hueErrors) {
        throw new ApiError_1.ApiError(`Error creating group: ${hueErrors[0].description}`, hueErrors[0]);
    }
    return { id: Number(result[0].success.id) };
}
function buildSensorConfigPayload(parameters) {
    if (!parameters || !parameters.sensor) {
        throw new ApiError_1.ApiError('A sensor must be provided');
    }
    if (!instanceChecks.isSensorInstance(parameters.sensor)) {
        throw new ApiError_1.ApiError('Sensor parameter is not a valid type, must be a Sensor');
    }
    const sensor = parameters.sensor.getHuePayload(), body = sensor.config;
    // Remove any parameters that we are not able to set, at least from experience at the time of writing
    delete body.reachable;
    return {
        type: 'application/json',
        body: body
    };
}
function buildSensorStatePayload(parameters) {
    if (!parameters || !parameters.sensor) {
        throw new ApiError_1.ApiError('A sensor must be provided');
    }
    if (!instanceChecks.isSensorInstance(parameters.sensor)) {
        throw new ApiError_1.ApiError('Sensor parameter is not a valid type, must be a Sensor');
    }
    let body;
    if (parameters.filterStateNames) {
        body = {};
        // Limit the updates to the specified stateNames
        parameters.filterStateNames.forEach((stateName) => {
            body.stateName = parameters.sensor.state[stateName];
        });
    }
    else {
        // Just copy all the state values, as these have not been filtered
        body = parameters.sensor.getHuePayload().state;
    }
    // Remove any parameters that we are not able to set, at least from experience at the time of writing
    delete body.lastupdated;
    return {
        type: 'application/json',
        body: body
    };
}
